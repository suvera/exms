<?php
declare(strict_types=1);

namespace dev\winterframework\pdbc\oci;

use dev\winterframework\pdbc\CallableStatement;
use dev\winterframework\pdbc\ex\CannotGetConnectionException;
use dev\winterframework\pdbc\ex\SQLException;
use dev\winterframework\pdbc\PreparedStatement;
use dev\winterframework\pdbc\ResultSet;
use dev\winterframework\pdbc\Statement;
use dev\winterframework\pdbc\support\AbstractConnection;
use dev\winterframework\pdbc\support\DatabaseMetaData;
use dev\winterframework\txn\Savepoint;
use PDO;
use RuntimeException;
use Throwable;

class OciConnection extends AbstractConnection {
    private mixed $oci = null;
    private array $savePoints = [];
    private array $clientInfo = [];
    private int $txnCounter = 0;
    private int $commitMode = OCI_COMMIT_ON_SUCCESS;

    public function __construct(
        private string $dsn,
        private ?string $username = null,
        private ?string $password = null,
        private array $options = []
    ) {
        $this->doConnect();
    }

    public function getResource(): mixed {
        $this->assertConnectionOpen();
        return $this->oci;
    }

    public function reConnect(): void {
        $this->doConnect();
    }

    private function doConnect() {
        $this->idleTimeout = $this->options['idleTimeout'] ?? 0;
        $this->lastAccessTime = time();
        $this->lastIdleCheck = time();

        $lang = $this->options['NLS_LANG'] ?? 'AMERICAN_AMERICA.UTF8';
        $df = $this->options['NLS_DATE_FORMAT'] ?? 'YYYY-MM-DD HH24:MI:SS';
        putenv('NLS_LANG=' . $lang);
        putenv('NLS_DATE_FORMAT=' . $df);
        $_ENV['NLS_LANG'] = $lang;
        $_ENV['NLS_DATE_FORMAT'] = $df;

        try {
            if ($this->options[PDO::ATTR_PERSISTENT]) {
                self::logInfo('Persistent OCI connection ');
                // both oci_connect() and oci_pconnect() cache the connection
                $this->oci = oci_connect(
                    $this->username,
                    $this->password,
                    $this->dsn
                );
            } else {
                self::logInfo('NON-Persistent OCI connection ');
                // Unlike oci_connect() and oci_pconnect(), oci_new_connect() does not cache
                // connections and will always return a brand-new freshly opened connection handle.
                $this->oci = oci_new_connect(
                    $this->username,
                    $this->password,
                    $this->dsn
                );
            }

            if (!$this->oci) {
                $e = oci_error();
                throw new RuntimeException(
                    $e['code']
                    . ': ' . htmlentities($e['message'], ENT_QUOTES)
                    . ', sqltext:' . ($e['sqltext'] ?? '')
                    . ', offset:' . (isset($e['offset']) ? $e['offset'] + 1 : '')
                );
            }

        } catch (Throwable $e) {
            throw new CannotGetConnectionException('Could not connect to datasource ' . $e->getMessage(), 0, $e);
        }
    }

    private function assertConnectionOpen(): void {
        $this->lastAccessTime = time();
        if (!isset($this->oci)) {
            self::logInfo("assertConnectionOpen ... reConnecting ...");
            $this->reConnect();
        }
    }

    public function getRowPreFetch(): int {
        if (isset($this->options[PDO::ATTR_PREFETCH]) && is_numeric($this->options[PDO::ATTR_PREFETCH])) {
            return intval($this->options[PDO::ATTR_PREFETCH]);
        }
        return 0;
    }

    /**
     * --------------------------
     * Implemented Methods
     */
    public function close($safe = false): void {
        if ($this->oci) {
            oci_close($this->oci);
            self::logInfo('OCI Connection Closed -  safe ' . $safe);
        }
        $this->oci = null;

    }

    public function getOci(): mixed {
        return $this->oci;
    }

    public function getCommitMode(): int {
        return $this->commitMode;
    }

    public function isClosed(): bool {
        return is_null($this->oci);
    }

    public function getDriverType(): string {
        return 'oci8';
    }

    public function getSchema(): string {
        $this->assertConnectionOpen();

        return $this->username;
    }

    public function createStatement(
        int $resultSetType = ResultSet::TYPE_FORWARD_ONLY
    ): Statement {
        $this->assertConnectionOpen();

        $stmt = new OciQueryStatement($this);
        $stmt->setResultSetType($resultSetType);
        return $stmt;
    }

    public function prepareStatement(
        string $sql,
        int $autoGeneratedKeys = Statement::NO_GENERATED_KEYS,
        array $columnIdxOrNameOrs = [],
        int $resultSetType = ResultSet::TYPE_FORWARD_ONLY
    ): PreparedStatement {
        $this->assertConnectionOpen();

        $stmt = new OciPreparedStatement($this, $sql);
        $stmt->setResultSetType($resultSetType);
        return $stmt;
    }

    public function prepareCall(
        string $sql,
        int $resultSetType = ResultSet::TYPE_FORWARD_ONLY
    ): CallableStatement {
        $this->assertConnectionOpen();

        $stmt = new OciCallableStatement($this, $sql);
        $stmt->setResultSetType($resultSetType);
        return $stmt;
    }

    public function getMetaData(): DatabaseMetaData {
        // TODO:
        return new DatabaseMetaData();
    }

    protected function inTransaction(): bool {
        return $this->txnCounter > 0;
    }

    public function beginTransaction(): void {
        $this->assertConnectionOpen();

        $this->txnCounter++;
        if ($this->txnCounter == 1) {
            $this->commitMode = OCI_NO_AUTO_COMMIT;
        }
    }

    public function commit(): void {
        $this->assertConnectionOpen();

        $this->txnCounter--;
        if ($this->txnCounter == 0) {
            oci_commit($this->oci);
            $this->commitMode = OCI_COMMIT_ON_SUCCESS;
        }
    }

    public function rollback(Savepoint $savepoint = null): void {
        $this->assertConnectionOpen();
        if (is_null($savepoint)) {
            $this->txnCounter--;
            if ($this->txnCounter == 0) {
                oci_rollback($this->oci);
                $this->commitMode = OCI_COMMIT_ON_SUCCESS;
            }
        } else {
            $this->releaseSavepoint($savepoint);
        }
    }

    public function setSavepoint(string $name = null): Savepoint {
        $this->assertConnectionOpen();
        if (is_null($name) || empty($name)) {
            $name = uniqid('ocisp_', true);
        }

        if (isset($this->savePoints[$name])) {
            throw new SQLException('Savepoint already exist with name ' . $name);
        }

        if (!preg_match('/^[a-zA-Z]+\w*$/', $name)) {
            throw new SQLException('Invalid Savepoint name ' . $name);
        }

        $sp = new Savepoint($name);
        $stid = oci_parse($this->oci, 'SAVEPOINT ' . $name);
        oci_execute($stid, OCI_NO_AUTO_COMMIT);
        oci_free_statement($stid);

        $this->savePoints[$name] = $sp;

        return $sp;
    }

    public function releaseSavepoint(Savepoint $savepoint): void {
        $this->assertConnectionOpen();

        $stid = oci_parse($this->oci, 'ROLLBACK TO SAVEPOINT ' . $savepoint->getName());
        oci_execute($stid, OCI_NO_AUTO_COMMIT);
        oci_free_statement($stid);
        unset($this->savePoints[$savepoint->getName()]);
    }

    public function isSavepointAllowed(): bool {
        return true;
    }

    public function setClientInfo(array $keyPair): void {
        throw new SQLException('Driver does not support this function ' . __METHOD__);
    }

    public function setSchema(string $schema): void {
        throw new SQLException('Driver does not support this function ' . __METHOD__);
    }

    public function setClientInfoValue(string $name, string $value): void {
        $this->assertConnectionOpen();
        $this->clientInfo[$name] = $value;
        oci_set_client_info($this->oci, $this->clientInfo[$name]);
    }

    public function getClientInfo(): array {
        return $this->clientInfo;
    }

    public function getClientInfoValue(string $name): string {
        return $this->clientInfo[$name] ?? '';
    }

}